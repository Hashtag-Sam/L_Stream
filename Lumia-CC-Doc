ğŸ§© Custom Overlay Layer
This layer is a real-time, configurable overlay component with support for dynamic events. It includes five main tabs:

HTML â€“ Defines the static layout of the UI
CSS â€“ Custom styling rules
JS â€“ Handles real-time logic and event listeners
Configs â€“ Input schema used to customize the component
Data â€“ Holds the actual values for the defined fields
Chat GPT Lumia Overlay Assistant
We offer a Chat GPT Lumia overlay assistant that can help you with your custom overlay creation. Ask it a question like Create an overlay that changes color every time a new chat command comes in. It knows our documentation and can help out a ton

Access it here: Chat GPT Lumia Overlay Assistant

ğŸ–¼ï¸ HTML Tab
Defines the layout of the overlay visible to users:

1<div style="padding:1em; font-family:sans-serif;">
2    <h3 id="msg">Waiting for dataâ€¦</h3>
3    <h4>Data:</h4>
4    <div id="data"></div>
5    <!-- You can use variables directly within HTML -->
6    <div>{{myvar}}</div>
7</div>
ğŸ¨ CSS Tab
Customize the visual style of your overlay:

1#msg {
2    font-weight: bold;
3    /* You can use variables directly within CSS */
4    color: '{{mycolor}}';
5}
ğŸ§  JS Tab
Javascript handles initialization and real-time event updates for your overlay:

1// window.Overlay is our primary api, you can use it with window.Overlay or just Overlay
2
3// Overlay.data contains he data that's submitted from the user using your overlay that they're allowed to fill out based on the fields in the config tab
4console.log(Overlay.data);
5
6// Call a command in Lumia Stream and pass variables for the command to use. In the command you can reference {{secret}} since that's what we're passing in
7Overlay.callCommand('mycommand', { secret: 'password' });
8
9// If the variables isn't already created it will create one.
10await Overlay.setVariable('myvar', 'this works');
11
12// Retrieves a variable
13await Overlay.getVariable('myvar');
14
15// If the variable was not previously created it may not automatically be replaced in your code until after the code is saved and reopened. If the overlay was previously made then it will update immediately. It may be helpful to add a check in your code to see if variable is already auto updating or not and toast the user to refresh the overlay
16const usedMyVar = "{{myvar}}";
17
18// You can call await without an async function since an async function is already wrapped around all the JS code
19
20// Save an item to storage
21await Overlay.saveStorage('mydata', 151);
22
23// Get an item from stoage
24const pokemonCaught = await Overlay.getStorage('mydata');
25
26// Delete an item from stoage
27await Overlay.deleteStorage('mydata');
28
29Overlay.on('chat', (data) => {
30    const username = data.username;
31    const avatar = data.avatar;
32    const message = data.message;
33    toast(`New chat message received from ${username}. They said ${message}`);
34});
35Overlay.on('alert', (data) => {
36    console.log('alert', data);
37    const settings = data.extraSettings;
38    const username = settings?.username || 'unknown';
39    const amount = data.dynamic.value;
40    const avatar = settings?.avatar;
41
42    if (data.alert === 'twitch-subscriber') {
43        if (data.dynamic.isGift) {
44            console.log(`${username} sent ${data.dynamic.giftAmount} with a tier ${settings.subPlan} sub to ${settings.recipients ?? settings.recipient}`);
45        } else if (data.dynamic.isResub) {
46            console.log(`${username} shared their ${settings.subPlan} sub. They've been subscribed for ${data.dynamic.subMonths} months`);
47        } else {
48            console.log(`${username} subscribed with a tier ${settings.subPlan} sub`);
49        }
50    }
51
52    if (data.alert === 'twitch-raid') {
53        console.log(`${username} just raided with ${data.dynamic.value} viewers`);
54    }
55
56    if (data.alert === 'kick-follower') {
57        console.log(`${username} just followed on Kick`);
58    }
59});
60Overlay.on('hfx', (data) => {
61    const username = data.username;
62    const command = data.command;
63    const message = data.message; // If the HFX was triggered with a message
64    const avatar = data.avatar;
65
66    console.log(`${username} just triggered HFX ${command}`);
67});
68Overlay.on('virtuallight', (data) => {
69    console.log('virtuallight', data);
70    const viratlLightId = data.uuid;
71    const brightness = data.brightness;
72
73    // Power sometimes does not come through if the light is just changing colors
74    if (data.color && (data.power || data.power === 'undefined')) {
75        const { r, g, b} = data.color;
76        console.log(`Light is changing to the color to rgb(${r},${g},${b})`);
77    } else if (data.power === false) {
78        console.log(`Light is turning off`);
79    }
80    const
81});
82// Only codeId that matches on both Overlays and Lumia will trigger this listener. codeId can only contain letters, numbers, hyphens, and underscores. Max 25 characters.
83Overlay.on('overlaycontent', (data) => {
84    const content = data.content;
85    console.log(`Content has been sent from Lumia Stream ${content}`);
86});
We wrap all the code in an async function, so you can use await in your root level of the code without wrapping it in an async funtion. This example will have no problem

1const variable = await Overlay.getStorage('mykey');
2console.log(variable);
What This Does
Displays the initial data provided via Ovelray.data
Accepts incoming events in real time
ğŸ“¡ Event Handling
Use the Overlay.on to listen to events

Example Event
If an event with type chat is dispatched and you have Overlay.on('chat') within your code it will send it to that listener

1Overlay.on('chat', (data) => {
2    console.log('chat', data);
3});
4Overlay.on('alert', (data) => {
5    console.log('alert', data);
6});
7Overlay.on('hfx', (data) => {
8    console.log('hfx', data);
9});
10Overlay.on('virtuallight', (data) => {
11    console.log('virtuallight', data);
12});
13Overlay.on('overlaycontent', (data) => {
14    console.log('overlaycontent', data);
15});
Showing Toasts
You can display toast notifications and log messages using the following:

1toast('Message');
2
3// Or you can pass in the type of toast to show
4toast('Message', 'info');
5toast('Message', 'success');
6toast('Message', 'warning');
7toast('Message', 'error');
Showing Logs in console
You can display log information in your console

1console.log('Message');
Calling Commands in Lumia Stream using the Overlay
We expose an api that allows you to call a chat command and update variables

This can be used under Overlay.callCommand

1Overlay.callCommand('caught');
2
3// Or you can pass local variables to your command as well that will only be used for this instance. This will not be a global variable
4Overlay.callCommand('caught', { username: 'lumia', pokemon: 'lugia', shiny: true });
Setting/Updating Global Variables in Lumia Stream
We expose an api that allows you to set a variable within Lumia Stream that can be used to save data to Lumia Stream and show it within commands, chatbots, or even other Overlay Layers.

We pull in varaibles dynamically so that overlays that are not using variables will not need to get the data for variables that it does not care about. This means that if you create a brand new variable within an overlay you may need to save and refresh so that it updates to pull in the new variable. But after the variable is created it will dynamically change.

This can be used under Overlay.setVariable

1Overlay.setVariable('pokemon_caught', 151);
Using Persistent Storage in Lumia Stream
We expose an api that allows you to get, update, and delete storage tied to your codeId. This will persist across Lumia Stream and can be used to communicate with your overlays in any place: OBS, Browser, Meld, etc. It works different than localStorage where localStorage only saves for the browser / streaming studio. If you would like to persist data this is the recommended way other than using it with variables. The only issue is that actual Lumia Stream does not have access to this storage currently. Only your Overlays will have access

This can be used under Overlay.saveStorage, Overlay.getStorage, Overlay.deleteStorage

1// Save an item to storage
2await Overlay.saveStorage('pokemon_caught', 151);
3
4// Get an item from stoage
5const pokemonCaught = await Overlay.getStorage('pokemon_caught');
6
7// Delete an item from stoage
8await Overlay.deleteStorage('pokemon_caught');
Data Storage Options in Custom Overlays
When building custom overlays, you have several options for storing and sharing data. Each method has its own use cases, benefits, and limitations:

1. localStorage
Scope: Only available in the browser where the overlay is loaded (e.g., OBS, browser source, or streaming studio).
Persistence: Data persists across page reloads in the same browser, but is not shared between different browsers or devices.
Use Case: Storing user preferences or temporary data that doesn't need to sync across devices or overlays.
Limitations: Not accessible by Lumia Stream itself or other overlays running elsewhere.
2. Lumia Stream Variables
Scope: Global within Lumia Stream. Variables can be accessed and updated by overlays, chatbots, commands, and other Lumia features.
Persistence: Saved on the server and available across all overlays and sessions.
Use Case: Sharing data between overlays, commands, and chatbots, or persisting state across restarts.
Limitations: All variables are globalâ€”be careful with naming to avoid conflicts.
3. Overlay.callCommand
Scope: Triggers a Lumia Stream command, optionally passing custom data.
Persistence: Depends on your command logic. You can implement your own storage or logic inside the command.
Use Case: Advanced workflows where you want to process data or trigger actions in Lumia Stream, possibly updating variables or storage as part of the command.
Limitations: Requires custom command setup in Lumia Stream.
4. Overlay.saveStorage / getStorage / deleteStorage
Scope: Persistent storage tied to your overlay's codeId. Data is saved on the local Lumia Stream server and is accessible from any overlay instance (e.g., OBS, browser, Meld) running on the same server.
Persistence: Data persists across overlay reloads and is shared between all overlay clients connected to the same Lumia Stream instance.
Use Case: Storing overlay-specific state or data that needs to be shared between multiple overlay clients or sessions.
Limitations:
Not accessible by Lumia Stream commands or chatbots (only overlays can read/write).
Not synced to the cloud or between different Lumia Stream servers.
Summary Table
Method	Scope/Access	Persistence	Accessible By	Best For
localStorage	Per browser/tab	Browser reloads	Overlay only	User preferences, local state
Lumia Stream Variables	Global (Lumia Stream)	Server-wide	Overlays, commands	Shared/global state, cross-feature access
Overlay.callCommand	Custom (via command logic)	Custom	Overlay & commands	Advanced workflows, custom logic
Overlay.saveStorage etc.	Per overlay codeId/server	Server (local)	Overlays only	Overlay-specific persistent data
Tip: Choose the storage method that best fits your data's scope and persistence needs. For most overlay-to-overlay communication, use variables or saveStorage. For global state, prefer variables. For overlay-local state, use localStorage or saveStorage.

ğŸ“‹ Configs Tab
The Configs fields define what users can customize in the layer. They appear on the right-hand side of the UI under the Configuration section unless a field is marked hidden: true.

A field object can now contain up to five useful properties:

Property	Required	Purpose	Example
type	âœ…	UI control to render. Must be one of the FieldType enum values (input, number, checkbox, dropdown, multiselect, colorpicker).	"type": "dropdown"
label	âœ…	Human-readable name shown in the sidebar.	"label": "Favorite Color:"
value	âŒ	Default value that appears the first time the user opens the overlay (also pre populates Overlay.data). Omit it to leave the field blank/unchecked on first load.	"value": 18
options	â˜‘ï¸*	Key value map of selectable choices. Required only for dropdown and multiselect; ignored for other types.	"options": { "twitch": "Twitch", "youtube": "YouTube" }
visibleIf	âŒ	Conditional render rule. Field is shown only if Overlay.data[visibleIf.key] strictly equals one of the values in visibleIf.equals.	"visibleIf": { "key": "targetKey", "equals": ["yes", "maybe"] }
hidden	âŒ	Hard-hide rule. When set to true, the field is never displayed in the Configs sidebar, preventing end users from altering it. The value still flows into Overlay.data, so the overlay can rely on it internally.
Useful for locking event subscriptions or other advanced settings.	"hidden": true
ğŸ”‘ Keys vs. Field Objects
Before looking at the individual properties (type, label, value, options), remember that the JSON key itself is critical:

1{
2    "age": {
3        /* field object */
4    },
5    "platform": {
6        /* field object */
7    }
8}
Concept	What it is	Where it shows up
Key ("age", "platform", â€¦)	The property name that wraps a field object	Becomes Overlay.data.age, Overlay.data.platform, etc. â€” this is what your JS code reads & writes
Label ("Age:", "Platform:")	UI text shown in the sidebar next to the control	Only visible to the user; never appears in Overlay.data
Rule of thumb: Choose short, machine-friendly keys (no spaces, camelCase is fine). Use labels for anything human-readable.

Supported Field Types
type	UI Control
"input"	Single-line text box
"number"	Numeric input spinner
"checkbox"	Checkbox selection
"dropdown"	Select menu
"multiselect"	Multi-select box
"colorpicker"	Color picker widget
Sample Config fields
1{
2    "txt": {
3        "type": "input",
4        "label": "Name:"
5    },
6    "last": {
7        "type": "input",
8        "label": "Last Name:",
9        "value": "Abc"
10    },
11    "partner": {
12        "type": "checkbox",
13        "label": "Partner:",
14        "value": false
15    },
16    "age": {
17        "type": "number",
18        "label": "Age:",
19        "value": 18
20    },
21    "color": {
22        "type": "colorpicker",
23        "label": "Favorite Color:"
24    },
25    "subcolor": {
26        "type": "colorpicker",
27        "label": "Sub-color:",
28        "visibleIf": {
29            "key": "color",
30            "equals": "blue"
31        }
32    },
33    "platform": {
34        "type": "dropdown",
35        "label": "Platform:",
36        "options": {
37            "twitch": "Twitch",
38            "youtube": "Youtube",
39            "kick": "Kick"
40        }
41    }
42}
Visible If Conditional Fields
The visibleIf field is a conditional statement that determines whether a field should be visible or not based on a condition. The visibleIf field is a JSON object with two keys: key and equals.

The key key is a string that represents the name of the field whose value should be used in the conditional statement. The equals key is a string, number, boolean, or an array that represents the value of the field whose value should be used in the conditional statement.

Single Prmitive Equals Example
1{
2    "hasAlerts": {
3        "type": "checkbox",
4        "label": "Show alerts"
5    },
6    "title": {
7        "type": "input",
8        "label": "Title",
9        "visibleIf": {
10            "key": "hasAlerts",
11            "equals": true
12        }
13    }
14}
Multiple Prmitive Equals Example
1{
2    "color": {
3        "type": "input",
4        "label": "Colors"
5    },
6    "subcolor": {
7        "type": "input",
8        "label": "Subcolors",
9        "visibleIf": {
10            "key": "color",
11            "equals": ["red", "blue", "green"]
12        }
13    }
14}
ğŸ“Š Data Tab
The data fields are the current values that the user has selected. These can have default values by adding them in to the initial Data Tab. This data is passed to your Javascript code that can be accessed under Overlay.data.

Data Tab Example

1{
2    "userSelectedColor": "#FF00FF"
3}
Then in your JS Tab you can access the color with Overlay.data.userSelectedColor

JS Tab

1const userColor = Overlay.data.userSelectedColor;
2console.log('User Color is', userColor);
When using Overlay.on the data tab must have the corresponding OverlayListener types:

OverlayListener types
Value	Label
chat	Chat messages
alert	Alerts
hfx	HFX
virtuallight	Virtual lights
overlaycontent	Custom Overlay Content
ğŸ’¡ Performance Tip: Only the selected events will be delivered to the overlay. ğŸ’¡ The typescript types for each alert is within the types tab ğŸ’¡ overlaycontent is a default event that will always be on for all custom overlays that are automatically subscribed to whether it's in the data tab or not. This is a special event that allows you to send custom content to the overlay from Lumia Stream and will only send to your specific codeId.

Code ID
The codeId is primarily meant to be used when talking to Lumia Stream. It is used to store storage data, it is used when calling send overlay content that will only send to overlays with that specific code id. It can be retrieved within the overlay using Overlay.on('overlaycontent', (data) => {...})

The codeId can only contain letters, numbers, hyphens, and underscores with a max of 25 characters.

âœ… Use Cases
Custom stream overlays for Twitch, YouTube, or other platforms
Real-time dashboards for alerts and interactions
Interactive visuals triggered by chat or external events
Pokemon Catching Mini Game
Duel Overlay to show matches on stream with your viewers
Persisting Data
The recommended way to persist data in your custom overlay is by using the provided Overlay.saveStorage and Overlay.setVariable methods. These allow you to store data that is scoped to your overlay's codeId and can be accessed across sessions, without relying on browser localStorage or global Lumia Stream variables.

Here's an example using Overlay.saveStorage to persist a counter:

1const countEl = document.getElementById('count');
2let counter = 0;
3
4load();
5// We need an async function when loading since getStorage is asynchronous
6async function load() {
7    counter = await Overlay.getStorage('counter');
8    render();
9}
10
11/* --- helper -----------------------------------------------------*/
12async function render() {
13    countEl.textContent = counter;
14    await Overlay.saveStorage('counter', counter); // persist
15}
16
17/* --- listen only to chat ---------------------------------------*/
18Overlay.on('chat', (data) => {
19    const username = data.username;
20    const avatar = data.avatar;
21    const message = data.message;
22    if (message === '!count') {
23        counter++;
24        render();
25    }
26    toast(`New chat message received from ${username}. They said ${message}`);
27});
Showing variables in your code
You can display the value of a variable or storage item in your overlay by directly accessing it the same way as you would do in a chatbot message, using double curly braces {{myvar}}. We will replace the variable in your HTML, CSS, and JS every time the variable changes. Just make sure it's a variable that exist in Lumia when the overlay loads as it will only update variables that exist. If you need to create a variable dynamically, create it in the overlay but then prompt to reload after the initial load. You can check to see if the variable exists within JS.

Variables can be used in these examples

1<div>{{myvar}}</div>
1div {
2    color: {{myvarcolor}};
3}
1const myvar = '{{myvar}}';
ğŸ“¤ Sending Data from Lumia Stream
Lumia Stream allows you to send data from your application to the overlay. This can be used to allow communication from Lumia Stream without needing variables. The way to do this is through either the Send Custom Overlay Content Overlay action or by using the overlaySendCustomContent action in your Custom Javascript code within a command. When using Send Custom Overlay Content Overlay action or overlaySendCustomContent it is required that you include the codeId otherwise there is no way the overlay will receive your content. The overlay will always only send to custom overlay layers with your codeId. An example of this would be in a command custom javascript code send:

1async function() {
2  overlaySendCustomContent({ codeId: "mycode", content: '{"type": "add", "value": "{{username}} - {{message}}"' });
3
4  // Make sure you call done() to avoid memory leaks
5  done();
6}
Then in your Custom Overlay JS Tab you would listen to it and parse it with:

1Overlay.on('overlaycontent', (data) => {
2    const content = JSON.parse(data.content);
3    toast('This is for my code', content);
4});
Using JS Game Engines
Our Overlays will work with various Game Engines including, but not limited to Phaser.js, Pixi.js, Three.js, and more.

ğŸ§ª Tips
Use the Events multiselect to limit which events trigger updatesâ€”great for debugging or focus.
Always sanitize HTML content if displaying user-generated input.
Leverage custom CSS to match your stream or brand style.
In custom code or overlay actions prefer to send data directly to the overlay without the store or variables if you do not need to persist the data.
